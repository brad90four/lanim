{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to \u03bbanim ! We\u2019re nowhere near what the GIF promises, but we\u2019re working on growing the documentation and the library itself. If you want to get started, check out the tutorial . If you want to see recipes for common use cases, look at the how-to guides . If you want to ask for help or just hang out, join our Discord server or use GitHub Discussions Roadmap for the near future: Docs: Make tutorials about all the basic concepts Hello, \u03bbanim! The coordinate system Projectors Imperative scene API APIs offered by pil Advanced guides Animating unexpected things Type annotations Defining your own renderable type Catalogue of examples Figure out which examples are needed Library: More primitives Line Ellipse More combinators Future: Intended audience? Use cases? Switching to SVG? GUI?","title":"Home"},{"location":"#welcome-to-anim","text":"We\u2019re nowhere near what the GIF promises, but we\u2019re working on growing the documentation and the library itself. If you want to get started, check out the tutorial . If you want to see recipes for common use cases, look at the how-to guides . If you want to ask for help or just hang out, join our Discord server or use GitHub Discussions","title":"Welcome to \u03bbanim!"},{"location":"#roadmap-for-the-near-future","text":"Docs: Make tutorials about all the basic concepts Hello, \u03bbanim! The coordinate system Projectors Imperative scene API APIs offered by pil Advanced guides Animating unexpected things Type annotations Defining your own renderable type Catalogue of examples Figure out which examples are needed Library: More primitives Line Ellipse More combinators Future: Intended audience? Use cases? Switching to SVG? GUI?","title":"Roadmap for the near future:"},{"location":"howtos/","text":"This is a stub","title":"How-to guides"},{"location":"tutorial/installation/","text":"Installing lanim External dependencies lanim requires some external programs to function. FFmpeg FFmpeg is used to create images from You should find instructions for installing it on the official website . LaTeX LaTeX is the engine behind text and equations. Besides LaTeX itself, you\u2019ll need three packages: standalone , amsmath and amssymb . The easiest way to go is to download a package with many common packages. Ubuntu: sudo apt-get install texlive-latex-extra Arch: pamac install texlive-latexextra Windows & Mac: Download MikTeX here: https://miktex.org/download (If you have a better way of doing this on Windows and Mac, please tell me!) Python You need Python 3.9 or higher to use lanim . Simply install the lanim package using pip . Verify the installation To make sure you installed lanim correctly, render the smoke test animation. python -m lanim -o smoke_test.mp4 lanim.examples.hello (substitute python for the right executable on your system) After running that, you should have a video called smoke_test.mp4 in your current folder. The default settings are: --width 1280 --height 720 --fps 30 . Let\u2019s try better ones: python -m lanim -w 1920 -h 1080 --fps 60 -o smoke_test.mp4 lanim.examples.hello Performance To see how fast animations will render on your machine, render the showcase animation. It\u2019s about a minute long. python -m lanim -o showcase.mp4 lanim.examples.showcase Then render the animation again to see how the cache speeds up the rendering.","title":"Installation"},{"location":"tutorial/installation/#installing-lanim","text":"","title":"Installing lanim"},{"location":"tutorial/installation/#external-dependencies","text":"lanim requires some external programs to function.","title":"External dependencies"},{"location":"tutorial/installation/#ffmpeg","text":"FFmpeg is used to create images from You should find instructions for installing it on the official website .","title":"FFmpeg"},{"location":"tutorial/installation/#latex","text":"LaTeX is the engine behind text and equations. Besides LaTeX itself, you\u2019ll need three packages: standalone , amsmath and amssymb . The easiest way to go is to download a package with many common packages. Ubuntu: sudo apt-get install texlive-latex-extra Arch: pamac install texlive-latexextra Windows & Mac: Download MikTeX here: https://miktex.org/download (If you have a better way of doing this on Windows and Mac, please tell me!)","title":"LaTeX"},{"location":"tutorial/installation/#python","text":"You need Python 3.9 or higher to use lanim . Simply install the lanim package using pip .","title":"Python"},{"location":"tutorial/installation/#verify-the-installation","text":"To make sure you installed lanim correctly, render the smoke test animation. python -m lanim -o smoke_test.mp4 lanim.examples.hello (substitute python for the right executable on your system) After running that, you should have a video called smoke_test.mp4 in your current folder. The default settings are: --width 1280 --height 720 --fps 30 . Let\u2019s try better ones: python -m lanim -w 1920 -h 1080 --fps 60 -o smoke_test.mp4 lanim.examples.hello","title":"Verify the installation"},{"location":"tutorial/installation/#performance","text":"To see how fast animations will render on your machine, render the showcase animation. It\u2019s about a minute long. python -m lanim -o showcase.mp4 lanim.examples.showcase Then render the animation again to see how the cache speeds up the rendering.","title":"Performance"},{"location":"tutorial/coordinates/","text":"The coordinate system In this tutorial, we\u2019re going to build this animation: 1. Drawing the axes We don\u2019t have a Line primitive, so we\u2019ll use very thin rectangles for lines. Good enough! The horizontal axis is drawn like this. It\u2019s just a static image, nothing fancy. from lanim.core import const_a from lanim.pil import Align , Group , Latex , Rect , Triangle def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) export = const_a ( horizontal_axis ( 16 )) In previous tutorials, we used some sort of \u201cunits\u201d without any explanation. Units are pretty simple: 1 unit equals 1/16th of the screen width. So if the dimensions of your animation are 16:9, your canvas is 16 units wide and 9 units high. The horizontal ( x ) axis points to the right, and the vertical axis ( y ) points down. The center of the screen is the origin \u2014 the point where x and y are both 0 . The vertical axis is pretty much the same. from lanim.core import const_a from lanim.pil import Align , Group , Latex , Rect , Triangle def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) export = const_a ( axes ) Now we\u2019ll add notches where the 1 mark is from lanim.core import const_a from lanim.pil import Align , Group , Latex , Rect , Triangle def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) notches = Group ([ Rect ( x = 1 , y = 0 , width = 0.05 , height = 0.5 , line_width = 2 ), Rect ( x = 0 , y = 1 , width = 0.5 , height = 0.05 , line_width = 2 ), ]) export = const_a ( Group ([ axes , notches ])) 2. Animating the point Let\u2019s make a function moving_point(x1, y1, x2, y2) that returns an animation This is what it\u2019s going to look like: def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): return Group ([ ... ]) return Animation ( 1 , projector ) (x, y) represents the point we\u2019re currently drawing def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) latex stores a formatter LaTeX string, like $(x:5.0, y:-3.0)$ . def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) We return a bundle of: the inner square the outer square a Latex object with the label def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) Now let\u2019s see it in action. from lanim.core import Animation from lanim.pil import Align , Group , Latex , Rect from lanim.easings import in_out def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) export = moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 Let\u2019s make the point go around in a loop. export = ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 + moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 + moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 ) If you have lots of animations, it can be inconvenient to use + . You can use the seq_a function, which essentially runs + on a list of animations. from lanim.core import Animation , seq_a ... export = seq_a ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 , moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 , moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 , ) 3. Combining the animations Let\u2019s rename the export of the previous animation to point_animation . Quote from lanim.core import Animation , seq_a , const_a from lanim.pil import Align , Group , Latex , Rect , Triangle from lanim.easings import in_out def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) #---------------------------------------# axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) notches = Group ([ Rect ( x = 1 , y = 0 , width = 0.05 , height = 0.5 , line_width = 2 ), Rect ( x = 0 , y = 1 , width = 0.5 , height = 0.05 , line_width = 2 ), ]) point_animation = seq_a ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 , moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 , moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 , ) export = const_a ( Group ([ axes , notches ])) What we need to do know is to make an animation which will play the point_animatino but place axes and notches in the background, so to speak. We will do it in three ways: a low-level one, a high-level one and finally using a built-in function. 3.1. The low-level way def total_projector ( t ): return Group ([ axes , notches , point_animation . projector ( t ) ]) export = Animation ( point_animation . duration , total_projector ) In this approach, we follow the requirements quite literally. For each value of t , we return a bundle of the axes, the notches and a frame of our dynamic animation. It works! But it\u2019s pretty long, and we have to make seure we supply the correct duration to Animation . 3.2. The high-level way Animations have a map method. It allows you to apply a function to each frame of the animation. export = point_animation . map ( lambda point : Group ([ axes , notches , point ])) A more advanced solution would be to use a bound method: export = point_animation . map ( Group ([ axes , notches ]) . add ) 3.3. gbackground lanim provides a built-in function to express adding a static background: from lanim.pil import gbackground ... export = gbackground ( point_animation , [ axes , notches ]) 4. Adding a delay Use the pause_after and pause_before functions to freeze for a given amount of seconds before the start or after the end of an animation. from lanim.core import Animation , pause_after , pause_before , seq_a ... export = gbackground ( point_animation , [ axes , notches ]) export = pause_after ( pause_before ( export , 2 ), 2 ) Try implementing these functions yourself as an exercise! The final program from lanim.pil import gbackground , Align , Group , Latex , Rect , Triangle from lanim.core import Animation , pause_after , pause_before , seq_a from lanim.easings import in_out def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) #---------------------------------------# axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) notches = Group ([ Rect ( x = 1 , y = 0 , width = 0.05 , height = 0.5 , line_width = 2 ), Rect ( x = 0 , y = 1 , width = 0.5 , height = 0.05 , line_width = 2 ), ]) point_animation = seq_a ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 , moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 , moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 , ) export = gbackground ( point_animation , [ axes , notches ]) export = pause_after ( pause_before ( export , 2 ), 2 ) 5. Recap In this tutorial: - you\u2019ve learned what coordinate system lanim uses - you\u2019ve learned how to combine a dynamic animation with a static background","title":"The coordinate system"},{"location":"tutorial/coordinates/#the-coordinate-system","text":"In this tutorial, we\u2019re going to build this animation:","title":"The coordinate system"},{"location":"tutorial/coordinates/#1-drawing-the-axes","text":"We don\u2019t have a Line primitive, so we\u2019ll use very thin rectangles for lines. Good enough! The horizontal axis is drawn like this. It\u2019s just a static image, nothing fancy. from lanim.core import const_a from lanim.pil import Align , Group , Latex , Rect , Triangle def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) export = const_a ( horizontal_axis ( 16 )) In previous tutorials, we used some sort of \u201cunits\u201d without any explanation. Units are pretty simple: 1 unit equals 1/16th of the screen width. So if the dimensions of your animation are 16:9, your canvas is 16 units wide and 9 units high. The horizontal ( x ) axis points to the right, and the vertical axis ( y ) points down. The center of the screen is the origin \u2014 the point where x and y are both 0 . The vertical axis is pretty much the same. from lanim.core import const_a from lanim.pil import Align , Group , Latex , Rect , Triangle def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) export = const_a ( axes ) Now we\u2019ll add notches where the 1 mark is from lanim.core import const_a from lanim.pil import Align , Group , Latex , Rect , Triangle def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) notches = Group ([ Rect ( x = 1 , y = 0 , width = 0.05 , height = 0.5 , line_width = 2 ), Rect ( x = 0 , y = 1 , width = 0.5 , height = 0.05 , line_width = 2 ), ]) export = const_a ( Group ([ axes , notches ]))","title":"1. Drawing the axes"},{"location":"tutorial/coordinates/#2-animating-the-point","text":"Let\u2019s make a function moving_point(x1, y1, x2, y2) that returns an animation This is what it\u2019s going to look like: def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): return Group ([ ... ]) return Animation ( 1 , projector ) (x, y) represents the point we\u2019re currently drawing def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) latex stores a formatter LaTeX string, like $(x:5.0, y:-3.0)$ . def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) We return a bundle of: the inner square the outer square a Latex object with the label def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) Now let\u2019s see it in action. from lanim.core import Animation from lanim.pil import Align , Group , Latex , Rect from lanim.easings import in_out def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) export = moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 Let\u2019s make the point go around in a loop. export = ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 + moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 + moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 ) If you have lots of animations, it can be inconvenient to use + . You can use the seq_a function, which essentially runs + on a list of animations. from lanim.core import Animation , seq_a ... export = seq_a ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 , moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 , moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 , )","title":"2. Animating the point"},{"location":"tutorial/coordinates/#3-combining-the-animations","text":"Let\u2019s rename the export of the previous animation to point_animation . Quote from lanim.core import Animation , seq_a , const_a from lanim.pil import Align , Group , Latex , Rect , Triangle from lanim.easings import in_out def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) #---------------------------------------# axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) notches = Group ([ Rect ( x = 1 , y = 0 , width = 0.05 , height = 0.5 , line_width = 2 ), Rect ( x = 0 , y = 1 , width = 0.5 , height = 0.05 , line_width = 2 ), ]) point_animation = seq_a ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 , moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 , moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 , ) export = const_a ( Group ([ axes , notches ])) What we need to do know is to make an animation which will play the point_animatino but place axes and notches in the background, so to speak. We will do it in three ways: a low-level one, a high-level one and finally using a built-in function.","title":"3. Combining the animations"},{"location":"tutorial/coordinates/#31-the-low-level-way","text":"def total_projector ( t ): return Group ([ axes , notches , point_animation . projector ( t ) ]) export = Animation ( point_animation . duration , total_projector ) In this approach, we follow the requirements quite literally. For each value of t , we return a bundle of the axes, the notches and a frame of our dynamic animation. It works! But it\u2019s pretty long, and we have to make seure we supply the correct duration to Animation .","title":"3.1. The low-level way"},{"location":"tutorial/coordinates/#32-the-high-level-way","text":"Animations have a map method. It allows you to apply a function to each frame of the animation. export = point_animation . map ( lambda point : Group ([ axes , notches , point ])) A more advanced solution would be to use a bound method: export = point_animation . map ( Group ([ axes , notches ]) . add )","title":"3.2. The high-level way"},{"location":"tutorial/coordinates/#33-gbackground","text":"lanim provides a built-in function to express adding a static background: from lanim.pil import gbackground ... export = gbackground ( point_animation , [ axes , notches ])","title":"3.3.  gbackground"},{"location":"tutorial/coordinates/#4-adding-a-delay","text":"Use the pause_after and pause_before functions to freeze for a given amount of seconds before the start or after the end of an animation. from lanim.core import Animation , pause_after , pause_before , seq_a ... export = gbackground ( point_animation , [ axes , notches ]) export = pause_after ( pause_before ( export , 2 ), 2 ) Try implementing these functions yourself as an exercise! The final program from lanim.pil import gbackground , Align , Group , Latex , Rect , Triangle from lanim.core import Animation , pause_after , pause_before , seq_a from lanim.easings import in_out def horizontal_axis ( width ): return Group ([ Rect ( x =- 0.3 , y = 0 , width = width - 0.6 , height = 0.04 , line_width = 2 ), Triangle ( x = width / 2 , y = 0 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 =- 0.6 , dy3 = 0.6 , line_width = 2 ), Latex ( x = 6.5 , y =- 0.1 , source = f \"$ { width } $\" , scale_factor = 0.75 , align = Align . CD ) ]) def vertical_axis ( height ): return Group ([ Rect ( x = 0 , y =- 0.3 , width = 0.04 , height = height - 0.6 , line_width = 2 ), Triangle ( x = 0 , y = height / 2 , dx1 = 0 , dy1 = 0 , dx2 =- 0.6 , dy2 =- 0.6 , dx3 = 0.6 , dy3 =- 0.6 , line_width = 2 ), Latex ( x = 0.1 , y = 3 , source = f \"$ { height } $\" , scale_factor = 0.75 , align = Align . LC ) ]) def moving_point ( x1 , y1 , x2 , y2 ): def projector ( t ): x = x1 * ( 1 - t ) + x2 * t y = y1 * ( 1 - t ) + y2 * t latex = f \"$(x: { x : .1f } , y: { y : .1f } )$\" return Group ([ Rect ( x , y , 0.05 , 0.05 , line_width = 2 ), Rect ( x , y , 0.25 , 0.25 , line_width = 0.7 ), Latex ( x , y - 0.1 , latex , align = Align . CD ) . scaled ( 0.4 ), ]) return Animation ( 1 , projector ) #---------------------------------------# axes = Group ([ horizontal_axis ( 16 ), vertical_axis ( 9 ) ]) notches = Group ([ Rect ( x = 1 , y = 0 , width = 0.05 , height = 0.5 , line_width = 2 ), Rect ( x = 0 , y = 1 , width = 0.5 , height = 0.05 , line_width = 2 ), ]) point_animation = seq_a ( moving_point ( x1 =- 3 , y1 = 2 , x2 = 5 , y2 =- 3 ) . ease ( in_out ) * 6 , moving_point ( x1 = 5 , y1 =- 3 , x2 =- 4 , y2 =- 3 ) . ease ( in_out ) * 4 , moving_point ( x1 =- 4 , y1 =- 3 , x2 =- 3 , y2 = 2 ) . ease ( in_out ) * 4 , ) export = gbackground ( point_animation , [ axes , notches ]) export = pause_after ( pause_before ( export , 2 ), 2 )","title":"4. Adding a delay"},{"location":"tutorial/coordinates/#5-recap","text":"In this tutorial: - you\u2019ve learned what coordinate system lanim uses - you\u2019ve learned how to combine a dynamic animation with a static background","title":"5. Recap"},{"location":"tutorial/hello/","text":"Hello, \u03bbanim! In this tutorial, we\u2019re going to recreate the lanim.examples.hello animation. 1. Create a stub Create a file called tutorial_hello.py with this content: from lanim.examples.hello import export Then run python -m lanim -o hello.mp4 tutorial_hello in the same directory. This explains how to make lanim animate your module: it needs to export the animation under the export name. Now we\u2019re going to make an 2. Create the greeting from lanim.pil import Latex sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) Theis object doesn\u2019t do anything yet \u2014 it\u2019s a simple value, like a number or a string. 3. Make a static animation of the sign from lanim.core import const_a from lanim.pil import Latex sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) export = const_a ( sign ) Now try python -m lanim -o hello.mp4 tutorial_hello and see what happens. This animation is only 1 second long, how do we make it longer? 3. Stretch the animation from lanim.core import const_a from lanim.pil import Latex sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) export = const_a ( sign ) * 5 The animation now lasts for five seconds. 4. Make the sign scale out instead of just sitting there from lanim.pil import Latex , appear sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) export = appear ( sign ) * 2 5. Create a border around the greeting from lanim.pil import Latex , Rect sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) How do we animate both of them? 6. Animate a pair of the greeting and the border from lanim.pil import appear , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = appear ( pair ) Pair is also an ordinary immutable value, like Latex and Rect . 7. Make the last frame persist for a while: from lanim.core import const_a from lanim.pil import appear , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = appear ( pair ) + const_a ( pair ) 8. Make the border appear before the sign 8.1. Make the sign appear inside the border from lanim.core import const_a from lanim.pil import appear , gbackground , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = gbackground ( appear ( sign ), [ border ]) + const_a ( pair ) gbackground accepts an animation and a list of things to put in the background. 8.2. Stretch out the border before the greeting animation from lanim.core import const_a from lanim.pil import appear , gbackground , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = appear ( border ) + gbackground ( appear ( sign ), [ border ]) + const_a ( pair ) 8.3. Split a complex expression across several lines from lanim.core import const_a from lanim.pil import appear , gbackground , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) + gbackground ( appear ( sign ), [ border ]) + const_a ( pair ) ) 9. Move the whole thing down from lanim.core import const_a from lanim.pil import appear , gbackground , move_by , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) + gbackground ( appear ( sign ), [ border ]) + const_a ( pair ) + move_by ( pair , dx = 0 , dy = 10 ) ) The animation is doing the action we wanted it to do, but it\u2019s not pretty. Let\u2019s fix that. 10. Add easings An easing function allows you to change the \u201cshape\u201d of the change. Animation Here you can see that The linear easing moves at a steady pace The in-out easing has a gentle start and end The sled easing starts out slow and then accelerates Formulas An easing is a function from [0; 1] to [0; 1] . You can see their graphs in action on Desmos from lanim.core import const_a from lanim.pil import appear , gbackground , move_by , Latex , Rect , Pair from lanim.easings import in_out , sled sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) + gbackground ( appear ( sign ), [ border ]) . ease ( in_out ) + const_a ( pair ) + move_by ( pair , dx = 0 , dy = 10 ) . ease ( sled ) ) 11. Adjust durations Timing is crucial. It\u2019s like the accents and intonation in speech. Let\u2019s spice our animation up by tweaking some of the durations. from lanim.core import const_a from lanim.pil import appear , gbackground , move_by , Latex , Rect , Pair from lanim.easings import in_out , sled sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) * 0.5 + gbackground ( appear ( sign ), [ border ]) . ease ( in_out ) + const_a ( pair ) * 0.25 + move_by ( pair , dx = 0 , dy = 10 ) . ease ( sled ) ) Recap In this tutorial, you\u2019ve learned how to: Export a simple animation from a Python module Create graphical objects, namely Latex , Rect and Pair Animate still frames, as well as scale out and move objects Change the duration of animations Put animations in sequence Use easings to make transitions more interesting","title":"Hello, \u03bbanim!"},{"location":"tutorial/hello/#hello-anim","text":"In this tutorial, we\u2019re going to recreate the lanim.examples.hello animation.","title":"Hello, \u03bbanim!"},{"location":"tutorial/hello/#1-create-a-stub","text":"Create a file called tutorial_hello.py with this content: from lanim.examples.hello import export Then run python -m lanim -o hello.mp4 tutorial_hello in the same directory. This explains how to make lanim animate your module: it needs to export the animation under the export name. Now we\u2019re going to make an","title":"1. Create a stub"},{"location":"tutorial/hello/#2-create-the-greeting","text":"from lanim.pil import Latex sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) Theis object doesn\u2019t do anything yet \u2014 it\u2019s a simple value, like a number or a string.","title":"2. Create the greeting"},{"location":"tutorial/hello/#3-make-a-static-animation-of-the-sign","text":"from lanim.core import const_a from lanim.pil import Latex sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) export = const_a ( sign ) Now try python -m lanim -o hello.mp4 tutorial_hello and see what happens. This animation is only 1 second long, how do we make it longer?","title":"3. Make a static animation of the sign"},{"location":"tutorial/hello/#3-stretch-the-animation","text":"from lanim.core import const_a from lanim.pil import Latex sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) export = const_a ( sign ) * 5 The animation now lasts for five seconds.","title":"3. Stretch the animation"},{"location":"tutorial/hello/#4-make-the-sign-scale-out-instead-of-just-sitting-there","text":"from lanim.pil import Latex , appear sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) export = appear ( sign ) * 2","title":"4. Make the sign scale out instead of just sitting there"},{"location":"tutorial/hello/#5-create-a-border-around-the-greeting","text":"from lanim.pil import Latex , Rect sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) How do we animate both of them?","title":"5. Create a border around the greeting"},{"location":"tutorial/hello/#6-animate-a-pair-of-the-greeting-and-the-border","text":"from lanim.pil import appear , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = appear ( pair ) Pair is also an ordinary immutable value, like Latex and Rect .","title":"6. Animate a pair of the greeting and the border"},{"location":"tutorial/hello/#7-make-the-last-frame-persist-for-a-while","text":"from lanim.core import const_a from lanim.pil import appear , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = appear ( pair ) + const_a ( pair )","title":"7. Make the last frame persist for a while:"},{"location":"tutorial/hello/#8-make-the-border-appear-before-the-sign","text":"","title":"8. Make the border appear before the sign"},{"location":"tutorial/hello/#81-make-the-sign-appear-inside-the-border","text":"from lanim.core import const_a from lanim.pil import appear , gbackground , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = gbackground ( appear ( sign ), [ border ]) + const_a ( pair ) gbackground accepts an animation and a list of things to put in the background.","title":"8.1. Make the sign appear inside the border"},{"location":"tutorial/hello/#82-stretch-out-the-border-before-the-greeting-animation","text":"from lanim.core import const_a from lanim.pil import appear , gbackground , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = appear ( border ) + gbackground ( appear ( sign ), [ border ]) + const_a ( pair )","title":"8.2. Stretch out the border before the greeting animation"},{"location":"tutorial/hello/#83-split-a-complex-expression-across-several-lines","text":"from lanim.core import const_a from lanim.pil import appear , gbackground , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) + gbackground ( appear ( sign ), [ border ]) + const_a ( pair ) )","title":"8.3. Split a complex expression across several lines"},{"location":"tutorial/hello/#9-move-the-whole-thing-down","text":"from lanim.core import const_a from lanim.pil import appear , gbackground , move_by , Latex , Rect , Pair sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) + gbackground ( appear ( sign ), [ border ]) + const_a ( pair ) + move_by ( pair , dx = 0 , dy = 10 ) ) The animation is doing the action we wanted it to do, but it\u2019s not pretty. Let\u2019s fix that.","title":"9. Move the whole thing down"},{"location":"tutorial/hello/#10-add-easings","text":"An easing function allows you to change the \u201cshape\u201d of the change. Animation Here you can see that The linear easing moves at a steady pace The in-out easing has a gentle start and end The sled easing starts out slow and then accelerates Formulas An easing is a function from [0; 1] to [0; 1] . You can see their graphs in action on Desmos from lanim.core import const_a from lanim.pil import appear , gbackground , move_by , Latex , Rect , Pair from lanim.easings import in_out , sled sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) + gbackground ( appear ( sign ), [ border ]) . ease ( in_out ) + const_a ( pair ) + move_by ( pair , dx = 0 , dy = 10 ) . ease ( sled ) )","title":"10. Add easings"},{"location":"tutorial/hello/#11-adjust-durations","text":"Timing is crucial. It\u2019s like the accents and intonation in speech. Let\u2019s spice our animation up by tweaking some of the durations. from lanim.core import const_a from lanim.pil import appear , gbackground , move_by , Latex , Rect , Pair from lanim.easings import in_out , sled sign = Latex ( x = 0 , y = 0 , source = r \"Hello, $\\lambda$anim!\" ) border = Rect ( x = 0 , y = 0 , width = sign . width () + 1 , height = sign . height () + 1 ) pair = Pair ( sign , border ) export = ( appear ( border ) * 0.5 + gbackground ( appear ( sign ), [ border ]) . ease ( in_out ) + const_a ( pair ) * 0.25 + move_by ( pair , dx = 0 , dy = 10 ) . ease ( sled ) )","title":"11. Adjust durations"},{"location":"tutorial/hello/#recap","text":"In this tutorial, you\u2019ve learned how to: Export a simple animation from a Python module Create graphical objects, namely Latex , Rect and Pair Animate still frames, as well as scale out and move objects Change the duration of animations Put animations in sequence Use easings to make transitions more interesting","title":"Recap"},{"location":"tutorial/how-does-lanim-work/","text":"How does Lanim work? In this tutorial, we\u2019re going to create an animated slider. You will learn how Lanim works under the hood along the way. 1. So what is an animation? If you open the source code of the Animation class and remove all the noise, this is what it is: class Animation ( Generic [ A ]): duration : float projector : Callable [[ float ], A ] Note If you\u2019re not familiar with type annotations (the stuff after : ), just ignore them. An animation consists of a duration (in seconds) and some function. We\u2019ll see what this function does in just a moment. 2. Let\u2019s write an animation from scratch Type this code into a file, e.g. how_does.py : from lanim.core import Animation from lanim.pil import Rect def projector ( t ): return Rect ( x = 0 , y = 0 , width = 3 , height = 2 + t * 4 ) export = Animation ( duration = 5.0 , projector = projector ) Then run it the usual way: python -m lanim -o how_does.mp4 how_does You should see this: The \u201cprojector\u201d thing works as follows: lanim will call the projector of an animation with increasing values of t: 0.0 , 0.01 , 0.02 , \u2026, and finally 1.0 . While doing so, it records all the frames (in this case, Rect objects) and renders them as images with the pillow library. That\u2019s it \u2014 no tricks up my sleeve. 3. Using standard functions from lanim.core import Animation from lanim.pil import Rect def projector1 ( t ): side = 2 + t * 3 return Rect ( x = 0 , y = 0 , width = side , height = side ) animation1 = Animation ( duration = 1.0 , projector = projector1 ) def projector2 ( t ): side = 5 return Rect ( x = t * 4 , y = 0 , width = side , height = side ) animation2 = Animation ( duration = 3.0 , projector = projector2 ) export = animation1 + animation2 The sum animation works in the same way: it receives a t ranging from 0 to 1, and it returns something renderable. It does so by picking one of the animations and adjusting the t value. For example, like this: def export_projector ( t ): if t < 1 / 4 : local_t = t * 4 return projector1 ( local_t ) else : local_t = ( t - 1 / 4 ) * ( 4 / 3 ) return projector2 ( local_t ) export = Animation ( 1.0 + 3.0 , export_projector ) Visualization Code (advanced) from functools import reduce from lanim.core import Animation from lanim.pil import lrpair_longest , Align , Group , Latex , Rect , Triangle def slider ( x1 : float , x2 : float , message : str , t : float ): slider_xpos = x1 * ( 1 - t ) + x2 * t bar = Rect ( x = ( x1 + x2 ) / 2 , y = 0 , width = x2 - x1 , height = 0.03 , line_width = 2 ) pointer = Triangle ( x = slider_xpos , y =- 0.3 , dx1 =- 0.3 , dy1 =- 0.2 , dx2 =+ 0.3 , dy2 =- 0.2 , dx3 = 0 , dy3 =+ 0.3 ) progress = Latex ( x = slider_xpos , y =- 0.7 , source = f \"$ { t : .2f } $\" , align = Align . CD ) . scaled ( 0.5 ) sign = Latex ( x = ( x1 + x2 ) / 2 , y = 0.2 , source = message , align = Align . CU ) . scaled ( 0.5 ) return Group ([ bar , pointer , progress , sign ]) def big_slider ( t : float ): slider_ = slider ( - 6 , 6 , \"animation1 + animation2\" , t ) . moved ( dx = 0 , dy =- 2.8 ) notch = Rect ( x =- 3 , y =- 2.8 , width = 0.02 , height = 0.55 , line_width = 2 ) return Group ([ slider_ , notch ]) def left_slider ( t : float ): return slider ( - 7 , - 2 , \"animation1 \\n\\n duration = 1\" , t ) . moved ( dx = 0 , dy = 2 ) def right_slider ( t : float ): return slider ( 2 , 7 , \"animation2 \\n\\n duration = 3\" , t ) . moved ( dx = 0 , dy = 2 ) def total_slider ( t : float ): if t < 1 / 4 : return left_slider ( t * 4 ) else : return right_slider (( t - 1 / 4 ) * ( 4 / 3 )) def conditional ( t : float ): if t < 1 / 4 : return Latex ( x = 0 , y = 0 , source = r \"$t < \\dfrac {1}{4} $\" ) . scaled ( 0.5 ) else : return Latex ( x = 0 , y = 0 , source = r \"$t \\ge \\dfrac {1}{4} $\" ) . scaled ( 0.5 ) export = reduce ( lrpair_longest , ( Animation ( 10 , total_slider ), Animation ( 10 , big_slider ), Animation ( 10 , conditional ), )) With some simple maths, you can do what + does like so: def plus ( animation1 , animation2 ): total_duration = animation1 . duration + animation2 . duration ratio = animation1 . duration / total_duration def projector ( t ): if t < ratio : return animation1 . projector ( t / ratio ) else : return animation2 . projector (( t - ratio ) / ( 1 - ratio )) return Animation ( total_duration , projector ) 4. Making the slider At the start, I promised that we\u2019re going to make a slider animation. A slider will consist of two things: a bar and a triangle that moves along that bar. We\u2019ll make a function that accepts some parameters and returns a Pair object. Here, x and y are the center of our slider, width is the width of the slider, and t is the progress \u2014 a value from 0 to 1 that tells where on the slider the triangle should be. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) For the bar, we\u2019ll use a very thin rectangle with a big line thickness. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) The Triangle class accepts the starting position (x, y) and three pairs (dx1, dy1) , (dx2, dy2) , (dx3, dy3) telling how far apart each of the three points is from (x, y) . For the x position, we will choose a value that depends on t . This is what\u2019s going to make the slide animated. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Finally, we bundle the bar and the triangle into a pair and return it. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) 5. Testing the slider Let\u2019s make a helper function that will act the projector . Then you can run the animation. from lanim.core import Animation from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) def projector ( t ): return make_slider ( x =- 3 , y =- 1 , width = 6 , t = t ) export = Animation ( 6.0 , projector ) 6. Attaching a number to the triangle In the previous animation, the slider had a varying number attached to it. Let\u2019s implement that as well. First, let\u2019s extract the x-coordinate of the slider into a variable. def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Then, let\u2019s add a Latex object with the number we want. The :.2f modifier formats a float with two decimal places. def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Here\u2019s the issue: a pair only accepts two values, but we need three. from lanim.pil import Pair , Rect , Triangle , Latex def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Solution: place the pair inside another pair def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( label , Pair ( bar , triangle )) Now let\u2019s run the code: The code so far from lanim.core import Animation from lanim.pil import Pair , Rect , Triangle , Latex def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( label , Pair ( bar , triangle )) def projector ( t ): return make_slider ( x =- 3 , y =- 1 , width = 6 , t = t ) export = Animation ( 6.0 , projector ) 7. Using a Group If you have more than 2 or 3 elements, nested pairs become inconvenient. Group is a generalization of Pair \u2014 it can hold any number of elements def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Group ([ bar , label , triangle ]) Recap Now you know that: An animation consists of a duration and a projector A projector is a function taking a number from 0 to 1 and returning an animation frame And now you can: Write an animation by constructing an Animation object yourself Animate a structure made up of multiple elements","title":"How does Lanim work?"},{"location":"tutorial/how-does-lanim-work/#how-does-lanim-work","text":"In this tutorial, we\u2019re going to create an animated slider. You will learn how Lanim works under the hood along the way.","title":"How does Lanim work?"},{"location":"tutorial/how-does-lanim-work/#1-so-what-is-an-animation","text":"If you open the source code of the Animation class and remove all the noise, this is what it is: class Animation ( Generic [ A ]): duration : float projector : Callable [[ float ], A ] Note If you\u2019re not familiar with type annotations (the stuff after : ), just ignore them. An animation consists of a duration (in seconds) and some function. We\u2019ll see what this function does in just a moment.","title":"1. So what is an animation?"},{"location":"tutorial/how-does-lanim-work/#2-lets-write-an-animation-from-scratch","text":"Type this code into a file, e.g. how_does.py : from lanim.core import Animation from lanim.pil import Rect def projector ( t ): return Rect ( x = 0 , y = 0 , width = 3 , height = 2 + t * 4 ) export = Animation ( duration = 5.0 , projector = projector ) Then run it the usual way: python -m lanim -o how_does.mp4 how_does You should see this: The \u201cprojector\u201d thing works as follows: lanim will call the projector of an animation with increasing values of t: 0.0 , 0.01 , 0.02 , \u2026, and finally 1.0 . While doing so, it records all the frames (in this case, Rect objects) and renders them as images with the pillow library. That\u2019s it \u2014 no tricks up my sleeve.","title":"2. Let's write an animation from scratch"},{"location":"tutorial/how-does-lanim-work/#3-using-standard-functions","text":"from lanim.core import Animation from lanim.pil import Rect def projector1 ( t ): side = 2 + t * 3 return Rect ( x = 0 , y = 0 , width = side , height = side ) animation1 = Animation ( duration = 1.0 , projector = projector1 ) def projector2 ( t ): side = 5 return Rect ( x = t * 4 , y = 0 , width = side , height = side ) animation2 = Animation ( duration = 3.0 , projector = projector2 ) export = animation1 + animation2 The sum animation works in the same way: it receives a t ranging from 0 to 1, and it returns something renderable. It does so by picking one of the animations and adjusting the t value. For example, like this: def export_projector ( t ): if t < 1 / 4 : local_t = t * 4 return projector1 ( local_t ) else : local_t = ( t - 1 / 4 ) * ( 4 / 3 ) return projector2 ( local_t ) export = Animation ( 1.0 + 3.0 , export_projector ) Visualization Code (advanced) from functools import reduce from lanim.core import Animation from lanim.pil import lrpair_longest , Align , Group , Latex , Rect , Triangle def slider ( x1 : float , x2 : float , message : str , t : float ): slider_xpos = x1 * ( 1 - t ) + x2 * t bar = Rect ( x = ( x1 + x2 ) / 2 , y = 0 , width = x2 - x1 , height = 0.03 , line_width = 2 ) pointer = Triangle ( x = slider_xpos , y =- 0.3 , dx1 =- 0.3 , dy1 =- 0.2 , dx2 =+ 0.3 , dy2 =- 0.2 , dx3 = 0 , dy3 =+ 0.3 ) progress = Latex ( x = slider_xpos , y =- 0.7 , source = f \"$ { t : .2f } $\" , align = Align . CD ) . scaled ( 0.5 ) sign = Latex ( x = ( x1 + x2 ) / 2 , y = 0.2 , source = message , align = Align . CU ) . scaled ( 0.5 ) return Group ([ bar , pointer , progress , sign ]) def big_slider ( t : float ): slider_ = slider ( - 6 , 6 , \"animation1 + animation2\" , t ) . moved ( dx = 0 , dy =- 2.8 ) notch = Rect ( x =- 3 , y =- 2.8 , width = 0.02 , height = 0.55 , line_width = 2 ) return Group ([ slider_ , notch ]) def left_slider ( t : float ): return slider ( - 7 , - 2 , \"animation1 \\n\\n duration = 1\" , t ) . moved ( dx = 0 , dy = 2 ) def right_slider ( t : float ): return slider ( 2 , 7 , \"animation2 \\n\\n duration = 3\" , t ) . moved ( dx = 0 , dy = 2 ) def total_slider ( t : float ): if t < 1 / 4 : return left_slider ( t * 4 ) else : return right_slider (( t - 1 / 4 ) * ( 4 / 3 )) def conditional ( t : float ): if t < 1 / 4 : return Latex ( x = 0 , y = 0 , source = r \"$t < \\dfrac {1}{4} $\" ) . scaled ( 0.5 ) else : return Latex ( x = 0 , y = 0 , source = r \"$t \\ge \\dfrac {1}{4} $\" ) . scaled ( 0.5 ) export = reduce ( lrpair_longest , ( Animation ( 10 , total_slider ), Animation ( 10 , big_slider ), Animation ( 10 , conditional ), )) With some simple maths, you can do what + does like so: def plus ( animation1 , animation2 ): total_duration = animation1 . duration + animation2 . duration ratio = animation1 . duration / total_duration def projector ( t ): if t < ratio : return animation1 . projector ( t / ratio ) else : return animation2 . projector (( t - ratio ) / ( 1 - ratio )) return Animation ( total_duration , projector )","title":"3. Using standard functions"},{"location":"tutorial/how-does-lanim-work/#4-making-the-slider","text":"At the start, I promised that we\u2019re going to make a slider animation. A slider will consist of two things: a bar and a triangle that moves along that bar. We\u2019ll make a function that accepts some parameters and returns a Pair object. Here, x and y are the center of our slider, width is the width of the slider, and t is the progress \u2014 a value from 0 to 1 that tells where on the slider the triangle should be. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) For the bar, we\u2019ll use a very thin rectangle with a big line thickness. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) The Triangle class accepts the starting position (x, y) and three pairs (dx1, dy1) , (dx2, dy2) , (dx3, dy3) telling how far apart each of the three points is from (x, y) . For the x position, we will choose a value that depends on t . This is what\u2019s going to make the slide animated. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Finally, we bundle the bar and the triangle into a pair and return it. from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle )","title":"4. Making the slider"},{"location":"tutorial/how-does-lanim-work/#5-testing-the-slider","text":"Let\u2019s make a helper function that will act the projector . Then you can run the animation. from lanim.core import Animation from lanim.pil import Pair , Rect , Triangle def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) triangle = Triangle ( x = x - width / 2 + t * width , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) def projector ( t ): return make_slider ( x =- 3 , y =- 1 , width = 6 , t = t ) export = Animation ( 6.0 , projector )","title":"5. Testing the slider"},{"location":"tutorial/how-does-lanim-work/#6-attaching-a-number-to-the-triangle","text":"In the previous animation, the slider had a varying number attached to it. Let\u2019s implement that as well. First, let\u2019s extract the x-coordinate of the slider into a variable. def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Then, let\u2019s add a Latex object with the number we want. The :.2f modifier formats a float with two decimal places. def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Here\u2019s the issue: a pair only accepts two values, but we need three. from lanim.pil import Pair , Rect , Triangle , Latex def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( bar , triangle ) Solution: place the pair inside another pair def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( label , Pair ( bar , triangle )) Now let\u2019s run the code: The code so far from lanim.core import Animation from lanim.pil import Pair , Rect , Triangle , Latex def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Pair ( label , Pair ( bar , triangle )) def projector ( t ): return make_slider ( x =- 3 , y =- 1 , width = 6 , t = t ) export = Animation ( 6.0 , projector )","title":"6. Attaching a number to the triangle"},{"location":"tutorial/how-does-lanim-work/#7-using-a-group","text":"If you have more than 2 or 3 elements, nested pairs become inconvenient. Group is a generalization of Pair \u2014 it can hold any number of elements def make_slider ( x , y , width , t ): bar = Rect ( x = x , y = y , width = width , height = 0.05 , line_width = 4 ) slider_xpos = x - width / 2 + t * width label = Latex ( x = slider_xpos , y = y + 0.5 , source = f \"$ { t : .2f } $\" ) . scaled ( 0.5 ) triangle = Triangle ( x = slider_xpos , y = y - 0.6 , dx1 =- 0.5 , dy1 =- 0.35 , dx2 = 0.5 , dy2 =- 0.35 , dx3 = 0 , dy3 = 0.5 , ) return Group ([ bar , label , triangle ])","title":"7. Using a Group"},{"location":"tutorial/how-does-lanim-work/#recap","text":"Now you know that: An animation consists of a duration and a projector A projector is a function taking a number from 0 to 1 and returning an animation frame And now you can: Write an animation by constructing an Animation object yourself Animate a structure made up of multiple elements","title":"Recap"}]}